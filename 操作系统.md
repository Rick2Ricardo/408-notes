# 操作系统

## 一、操作系统概述

### 1、操作系统的概念（定义）功能和目标

#### 操作系统的概念（定义）

**操作系统**(Operating System，OS），是指**控制**和**管理**整个计算机系统和硬件和软件资源，并合理地组织调度计算机的工作和资源分配；以**提供给用户和其他软件方便的接口和环境**；它是计算机系统中最基本的**系统软件**。

##### （1）作为系统资源的管理者

> **提供的功能：**
>
> + 处理机管理
> + 存储器管理
> + 文件管理
> + 设备管理
>
> **目标：**安全有效
>
> **补充知识：**执行一个程序前需要将该程序放到内存当中，才能被CPU出处理

##### （2）向上层提供方便易用的服务

> 封装思想：操作系统把一些丑陋的硬件功能封装成简单易用的服务，使得用户能更方便地使用计算机，用户无需关心底层硬件原理，只需要对操作系统底层发出命令即可。
>
> **GUI：图形化用户接口（Graphical User Interface）**
>
> 用户可以使用形象的图形化界面进行操作，而不再需要记忆复杂的命令、参数。
>
> **联机命令接口**
>
> 实例（windows系统） 联机命令接口=交互式命令接口
>
> **特点：**用户说一句，系统跟着做一句
>
> **脱机命令接口**
>
> 实例（Windows系统） 脱机命令接口=批处理命令接口
>
> **特点**：用户说一堆，系统跟着做一堆
>
> **程序接口**
>
> 可以在程序中进行系统调用来使用程序接口，普通用户不能直接使用程序接口，只能通过程序代码间接使用。
>
> **如：**写C语言“Hello world”时，在printf函数底层就使用到了操作系统提供的显式相关的“系统调用”
>
> 在有的教材当中：系统调用=广义指令

##### （3）作为最接近硬件的层次

> 没有任何软件支持的计算机称作裸机。在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更加方便的机器。
>
> 操作系统对硬件机器的拓展：将CPU、内存、磁盘、显示器、键盘等硬件合理地组织起来，让各种硬件能够互相协调配合，实现更多更复杂的功能。

### 2、操作系统的四个特征

并发、共享、虚拟、异步（并发和共享是最基本的特征，二者互为存在条件）

#### 并发

> **概念：**指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。
>
> 常考易混淆的概念----并行：指两个或多个事件在同一时刻同时发生。
>
> **并发vs并行**
>
> **操作系统的并发性**指计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行的，而微观上看是交替运行的。
>
> 操作系统就是伴随着“多道程序技术”而出现的。因此，**操作系统和程序并发是一起诞生的。**
>
> **重要考点**：
>
> **单核CPU**同一时刻只能执行一个程序，各个程序只能并发地执行
>
> **多核CPU**同一时刻可以同时执行多个程序，多个程序可以并行地执行
>
> 比如Intel的第八代i3处理器就是**4核CPU**，意味着可以**并行地执行4个程序**

#### 共享

> **概念：**共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用
>
> **互斥共享方式：**系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源
>
> + 例：使用QQ和微信视频，同一时间段内摄像头只能分配给其中一个进程
>
> **同时共享方式：**系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问
>
> + 使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件，说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。
>
> **注意：**
>
> + 如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义
> + 如果失去共享性，则微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发

#### 虚拟

> **概念：**虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。
>
> **空分复用技术**----虚拟存储器
>
> **时分复用技术**----虚拟处理器技术：虽然只有一个CPU，但是能同时运行多个程序，微观上处理机在各个微小的时间段内交替着为各个进程服务。
>
> 注意：
>
> + 如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，没有并发性，就谈不上虚拟性

#### 异步

> **概念：**异步是指在多少程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是程序的异步性。
>
> 由于并发运行的程序会争抢着使用系统资源，而系统中的资源有限，因此进程的执行不是一贯到底地，而是走走停停的，以不可预知的速度向前推进。
>
> **注意：**
>
> + 如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。**只有系统拥有并发性，才有可能导致异步性。**

### 3、操作系统的发展与分类

####  （1）手工操作阶段 

![image-20240619105709383](操作系统.assets/image-20240619105709383.png)

**主要缺点：**用户独占全机、人机速度矛盾导致资源利用率极低

#### （2）批处理阶段----单道批处理系统

引入脱机输入/输出技术，并由监督程序负责控制作业的输入输出

![image-20240619110053360](操作系统.assets/image-20240619110053360.png)

**主要优点：**缓解了一定程度的人机速度矛盾，资源利用率有所提升。

**主要缺点：**内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序。CPU有大量的时间是在空闲等待I/O完成。资源利用率依然很低。

### 4、操作系统的运行机制

预备知识：程序是如何运行的？

由高级语言翻译为机器指令，程序运行的过程其实就是CPU执行一条一条的机器指令的过程

#### （1）内核程序和应用程序

> 我们普通程序员写的程序就是”**应用程序**“
>
> 微软、苹果由一帮人负责实现操作系统，他们写的就是”**内核程序**“

#### （2）特权指令和非特权指令

> 应用程序只能使用“**非特权指令**”如：加法指令、减法指令等
>
> 操作系统内核作为”管理者“有时候会让CPU执行一些”**特权指令**“，如：内存清零指令。这些指令影响重大，只允许”管理者”-----即操作系统内核来使用

#### （3）内核态和用户态

> CPU有两种状态，“内核态”和“用户态”
>
> 处于**内核态**时，说明此时正在运行的是**内核程序**，此时可以执行**特权指令**。
>
> 处于**用户态**时，说明此时正在运行的是**应用程序**，此时只能执行**非特权指令**。

#### （4）内核

> 内核是操作系统最重要的核心部分。
>
> 很多内核程序组成操作系统内核

#### （5）内核态、用户态的切换

> **内核态-->用户态**：执行一条特权指令----修改PSW的标志位为“用户态”。这个动作意味着操作系统将主动让出CPU使用权
>
> **用户态-->内核态**：由“中断”引发，硬件中断信号意味着操作系统将强行夺回CPU的使用权

### 5、中断和异常

#### （1）中断的作用

> CPU上会运行两种程序，一种是操作系统内核程序，一种是应用程序。
>
> “中断”是**让操作系统内核夺回CPU使用权**的唯一途径
>
> 如果没有“中断”机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序(既然如此，何来“并发”)。

#### （2）中断的类型

> **内中断(也称异常、例外)**
>
> 例1：试图在用户态下执行特权指令
>
> 例2：执行除法指令时发现除数为0
>
> 例3：有时候应用程序想要请求操作系统内核的服务，此时会执行一条特殊的指令--陷入指令，该指令会引发一个内部中断信号
>
> 注：
>
> + 执行“陷入指令”，意味着应用程序主动地将CPU控制权还给操作系统内核。“系统调用”就是通过陷入指令完成地。
> + 与当前执行的指令有关，中断信号来自CPU内部
>
> **外中断（也称“中断”）**
>
> 例1：时钟中断----由时钟部件发来的中断信号（使得多个程序并发运行）
>
> 例2：I/O中断----由输入/输出设备发来的中断信号（当输入输出任务完成时，向CPU发出中断信号）
>
> 注：
>
> + 每一条指令执行结束，CPU都会例行检查是否有外中断信号
> + 与当前执行的指令无关，中断信号来源于CPU外部

#### （3）中断机制的基本原理

> 不同的中断信号，需要不同的中断处理程序来处理。当CPU检测到中断信号后，会根据中断信号的类型去查询“**中断向量表**”，以此来找到相应的中断处理程序在内存中的存放位置。
>
> 显然，中断程序一定是内核程序，需要运行在“内核态”

### 6、系统调用

#### 1）系统调用的定义

> “系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，==应用程序可以通过系统调用来请求获得操作系统内核的服务==。

#### 2）系统调用与库函数的区别

> <img src="操作系统.assets/image-20240813114506915.png" alt="image-20240813114506915" style="zoom:33%;" />

#### 3）为什么操作系统是必须的

> 由操作系统内核对共享资源进行统一管理，并向上提供“系统调用”，用户进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求。内核会对各个请求进行协调处理。

#### 4）什么功能要用到系统掉用

> 应用程序通过==系统调用==请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此==凡是与共享资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求==，由操作系统内核代为完成。这样==可以保证系统的稳定性和安全性==，防止用户进行非法操作。

#### 5）系统调用的过程

> ![image-20240818090109144](操作系统.assets/image-20240818090109144.png)
>
> 传递系统调用参数—>执行陷入指令（==用户态==）—>执行相应的内请求核程序处理系统调用（==核心态==）—>返回应用程序
>
> 注意：
>
> + ==陷入指令==是在==用户态==执行的，执行陷入指令之后立即引发一个==内中断==，使CPU==进入核心态==
> + 发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行
>
> 注意别名：陷入指令=trap指令=访管指令

### 7、操作系统体系结构

> <img src="操作系统.assets/image-20240818091254552.png" alt="image-20240818091254552" style="zoom:33%;" />
>
> + 原语是一种特殊的程序，具有原子性。也就是说，这段程序的运行必须一气呵成，不可被中断
> + Ubuntu、CentOS的开发团队主要工作是实现非内核功能，而内核都是用了Linux内核

#### 1）操作系统内核

![image-20240818091701254](操作系统.assets/image-20240818091701254.png)

#### 2）大内核和微内核性能对比

> ![image-20240818091948581](操作系统.assets/image-20240818091948581.png)
>
> 注意：==变态(CPU状态的转换)的过程是有成本的==，要消耗不少时间，==频繁地变态会降低系统性能==

#### 3）大内核

> 将操作系统的主要功能模块都作为系统内核，运行在核心态
> 优点：高性能
> 缺点：内核代码庞大，结构混乱，难以维护
>
> 典型的 ==大内核/宏内核/单内核== 操作系统：Linux、UNIX

#### 4）微内核

> 只把最基本的功能保留在内核
> 优点：内核功能少，结构清晰，方便维护
> 缺点：需要频繁地在核心态和用户态之间切换，性能低
>
> 典型的 ==微内核== 操作系统：Windows NT

### 8、操作系统引导

> 安装操作系统后
>
> ![image-20240818093533848](操作系统.assets/image-20240818093533848.png)

#### 1）操作系统引导（开机过程）

> ![image-20240818093817983](操作系统.assets/image-20240818093817983.png)
>
> 注：
>
> + BIOS：Basic Input/Output System
>
> ==操作系统引导==：
>
> 1. CPU从一个特定的主存地址开始，取指令，执行ROM中的引导程序（先进行硬件自检，再开机）
> 2. 将磁盘的第一块——主引导记录读入内存，执行磁盘引导程序，扫描分区表
> 3. 从活动分区（又称主分区，即安装了操作系统的分区）读入分区引导记录，执行其中的程序
> 4. 从根目录下找到完整的操作系统初始化程序（即启动管理器）并执行，完成“开机”的一系列工作

### 9、虚拟机

#### 1）传统计算机

> ![image-20240818094939275](操作系统.assets/image-20240818094939275.png)
>
> 一个机器上只能安装一个操作系统的局限性

#### 2）虚拟机

> 虚拟机：使用虚拟化技术，将一台物理机器虚拟化为多态虚拟机器（Virtual Machine，VM）每个虚拟机器都可以独立运行一个操作系统
>
> 同义术语：虚拟机管理程序/虚拟机监控程序/Virtual Machine Monitor/Hypervisor
>
> ![image-20240818095919614](操作系统.assets/image-20240818095919614.png)

#### 3）两类虚拟机管理程序（VMM）的对比

<img src="操作系统.assets/image-20240818100707514.png" alt="image-20240818100707514" style="zoom:33%;" />



## 二、进程管理

### 1、进程的概念、组成、特征

#### （1）进程的概念

> **程序：**是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合
>
> **进程：**是动态的，是程序的一次执行过程（同一个程序多次执行会对应多个进程）
>
> ##### 思考：操作系统是这些进程的管理者，它要怎么区分各个进程？
>
> 当程序被创建时，操作系统会为该进程分配一个唯一的、不重复的“身份证号”——PID (Process ID,进程ID)

#### （2）进程的组成

> 更加确切的说，应该是”进程实体(进程映像)“由PCB、程序段、数据段组成。
>
> ##### 1）进程的组成——PCB
>
> 操作系统给要记录的**PID**、进程所属**用户ID（UID）**
>
> 还要记录给进程**分配了哪些资源**（如：分配了多少内存、正在使用哪些I/O设备、正在使用哪些文件）
>
> 还要记录进程的**运行情况**（如：CPU使用时间、磁盘使用情况、网络流量使用情况等等）
>
> 这些信息都被保存在一个数据结构PCB（Process Control Block）中，即进程加快
>
> 操作系统需要对各个并发运行的进程进行管理，但凡管理时所需要的信息，都会被放进PCB中
>
> PCB是进程存在的唯一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB。
>
> **PCB是给操作系统使用的。**
>
> ##### 2）进程的组成——程序段、数据段
>
> **程序段：**程序的代码（指令序列）
>
> **数据段：**运行过程中产生的各种数据（如：程序中定义的变量）
>
> **程序段、数据段是给进程自己用的。**
>
> #### 知识滚雪球：程序是如何运行的？
>
> 一个进程实体（进程映像）由PCB、程序段、数据段组成。
>
> 进程是动态的，进程实体（进程映像）是静态的。
>
> 进程实体反应了进程在某一时刻的状态（如：x++后，x=2）
>
> **进程**是进程实体的**运行过程**，是系统进行**资源分配**和**调度**的一个独立单位。
>
> **注意：**PCB是进程存在的唯一标志

#### （3）进程的特征

> 程序是静态的，进程是动态的，相比于程序，进程拥有一下特征：
>
> 1. **动态性：**进程是程序的一次执行过程，是动态地产生、变化和消亡的
> 2. **并发性：**内存中有多个进程实体，各进程可并发执行
> 3. **独立性：**进程是能独立运行、独立获得资源、独立接受调度地基本单位
> 4. **异步性：**各进程按各自独立、不可预知的速度向前推进，操作系统要提供给”进程同步机制“来解决异步问题
> 5. **结构性：**每个进程都会配置一个PCB。结构上看进程由程序段、数据段、PCB组成

### 2、进程的状态与转换

#### （1）进程的状态

> 1. **创建态：**创建态进程正被创建时，它的状态是”创建态”，在这个阶段操作系统会为进程分配资源、初始化PCB
> 2. **就绪态：**当进程创建完成后，便进入”就绪态“处于就绪态的进程已具备运行条件，但由于没有空闲CPU，就暂时不能运行
> 3. **运行态：**如果一个进程此时在CPU上运行，那么这个进程处于”运行态“，CPU会执行该进程对应的程序（执行指令序列）
> 4. **阻塞态：**在程序运行的过程中，可能会请求等待某个事件的发生（如等待某种系统资源的分配，或者等待其他进程的相应）。在这个事件发生之前，进程无法继续往下执行，此操作系统会让这个进程下CPU，并让它进入“阻塞态”，当CPU空闲时，又会选择另一个“就绪态”进程上CPU运行。
> 5. **终止态：**一个进程可以执行exit系统调用，请求操作系统终止该进程。此时该进程会进入“终止态”，操作系统会让该进程下CPU，并回收内存空间等资源，最后还要回收该进程的PCB。当终止进程的工作完成之后，这个进程就彻底消失了。

#### （2）进程状态的转换

> ![image-20240818102229844](操作系统.assets/image-20240818102229844.png)

#### （3）进程的组织——链接方式

> ![image-20240818102508433](操作系统.assets/image-20240818102508433.png)
>
> 以队列的形式

#### （4）进程的组织——索引方式

>  <img src="操作系统.assets/image-20240818102611998.png" alt="image-20240818102611998" style="zoom:33%;" />
>
> 大多数的操作系统都是链接方式